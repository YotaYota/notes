# Rust

- Statically typed

## Commandline

### rustup

CLI for managing rust and associated tools.

update Rust

```sh
rustup update
```

Documentation

```sh
rustup doc
```

Uninstall

```sh
rustup self uninstall
```

### rustc

Compiler

```sh
rustc main.rs
```

### rustfmt

Format code

```sh
rustfmt
```

### cargo

Build system and package manager

- Crates _Cargo.toml_
- Autogenerated _Cargo.lock_

Create new project

```sh
cargo new <project-name>
```

Compile binary in _target/debug/_ directory

```sh
cargo build
```

Compile binary with optimizations in _target/release/_ directory

```sh
cargo build --release
```

Compile and run

```sh
cargo run
```

Checks code without compiling

```sh
cargo check
```

Open documentation

```sh
cargo doc --open
```

## File structure

```sh
.
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src
â”‚Â    â””â”€â”€ main.rs
â””â”€â”€ target
     â””â”€â”€ debug
     â””â”€â”€ release
```

## Running

Entrypoint is the `main` function

```rust
fn main() {
    Ok(())
}
```

The _prelude_ is the list of things that Rust automatically imports into every
Rust program. Eg `std::result::Result::{self, Ok, Err}`;

## Dependencies

_Cargo.toml_: dependencies used by cargo.

_Cargo.io_: registry of dependencies.

## Variables

- `let`: define variable.
- `const`: define constant.

_Note:_ `const` variables must have type annotation.

_Note:_ `const` variables must be assigned to a compile time expression.

### Ownership (variables on the heap)

_Ownership_ is an alternative to garbage collection and manual memory
allcoation.

- Each value has a variable that's called its owner.
- There can only be one owner at a time.
- When the owner goes out of scope, the value will be dropped (the function
  `drop` is called).

if another variable is assigned to its value, the value is moved and the old
variable is invalidated.

```rust
let s1 = String::from("a string");
let s2 = s1; // s1 is invalidated here
println!("{}", s1); // panic
```

_Note_: For _stack_ data, values are always copied, ie types with known size
at compile time.

_Note_: If a type implements the `Copy` trait, an older variable is still
usable after assignment. Rust won't let us annotate a type with the `Copy`
trait if the type, or any of its parts, has implemented the `Drop` trait.

#### Ownership and Functions

Passing a variable to a function will move or copy in the same way a assignment
does.

```rust
fn main() {
  let s1 = String::from("a string");
  let s2 = take_and_gives_back(s1);
  takes_ownership(s2);
}

fn gives_ownership() {
  let s = String::from("a string");
  s
}

fn takes_ownership(s: String) {
  println!("{}", s);
}

fn take_and_gives_back(s: String) {
  s
}
```

### References and Borrowing

`&` is the reference operator. References refer to a value without taking
ownership.

```rust
fn main() {
  let s = String::from("a string");
  let len = calc_length(&s);   // s is borrowed
  println!("{} - {}", s, len); // s was not dropped
}

fn calc_length(&s: String) -> usize {
}
```

_Note_: Any amount of immutable borrows are allowed at the same time (as long
as there are no mutable borrows).

_Note_: The compiler will ensure that data will not go out of scope before a
reference to the data does, ie no _dangling pointers_.

#### Mutable Reference

`&mut`

- There can only be _one_ mutable borrow at a time.
- There cannot be a mutable borrow at the same time as there are immutable
  borrows.

```rust
fn main() {
  let mut s = String::from("hello");

  let r1 = &s; // no problem
  let r2 = &s; // no problem
  println!("{} and {}", r1, r2);
  // variables r1 and r2 will not be used after this point

  let r3 = &mut s; // no problem
  println!("{}", r3);
}

```

_Note_: The compiler uses _Non-Lexical Lifetimes_ to know a variable is not in
use before its scope ends.

### Immutability

Varibles are _immutable_ by default.

Use `mut` keyword to make _mutable_ variables.

_Note:_ `const` variables cannot be `mut`.

### Scalar types

| Length  | Signed  | Unsigned | Floating |
| :------ | :------ | :------- | :------- |
| 8-bit   | `i8`    | `u8`     |          |
| 16-bit  | `i16`   | `u16`    |          |
| 32-bit  | `i32`   | `u32`    | `f32`    |
| 64-bit  | `i64`   | `u64`    | `f64`    |
| 128-bit | `i128`  | `u128`   |          |
| arch    | `isize` | `usize`  |          |

_Note:_ Literal integers default to `i32` or `f64` unless suffix is used.

_Note:_ Literal integers can contain underscores, eg `1_000`.

_Note:_ `isize` and `usize` depend on the computer architecture: 64 bits on a
64-bit architecture and 32 bits on a 32-bit architecture.

_Note:_ In debug mode, integer overflow will panic, but in release mode it will
overflow. Can be handled with `wwrapping_*`, `checked_*`, `overflowing_*` and
`saturating_*` methods.

#### Characters

- 4 bytes
- Unicode Scalar Value
- Wrapped in single-quotes, eg `let c: char = 'ðŸ˜»'`

### Compound Types

Arrays and tuples.

#### Tuples

Fixed size

```rust
let tup: (i32, f64, u8) = (42, 3.14, 1);
```

Can be destructured with pattern matching

```rust
let (x, y, z) = tup;
```

Individual elements can be accessed with `.<index>`

```rust
let x = tup.2;
```

The empty tuple `()` is called the _unit type_ and the value is called the
_unit value_. Expressions implicitly return the unit value if they don't return
any other value.

#### Arrays

- All elements must have the same type
- Fixed length
- Lives on the stack

```rust
let arr: [i32, 3] = [1, 2, 3];
```

To initialize an array with the same value

```rust
let arr = [3; 5];
```

### Shadowing

Variables can be shadowed by reusing the `let` keyword.

```rust
let spaces = "     ";
let spaces = spaces.len();
```

### Reference

`&` indicates a _reference_.

## Control flow

### `if`

_Note_: `if` is an expression, thus it can eg be used in a `let` statement.

_Note_: `condition` must be a `bool`.

```rust
if condition {
} else if {
} else {
}

```

### `match`

must cover all arms.

### `if let`

Shorthand for covering on only one arm.

```rust
if let Ok(i) = h() 
  // ...
}
```

### `while let`

### `?`

Shorthand for match or throw error.

### Loops

`loop`, `while` and `for`.

#### `while`

```rust
while index < 5 {
  // snip
}
```

#### `for`

```rust
for e in elements {
  // snip
}
```

#### `loop`

- `break`
- `break return_value;`
- `continue`

_Note_: can use labels, eg

```rust
'a_label: loop {
  break 'a_label;
}
```

## Types

Types not in the prelude can be brought into scope with a `use` statement.

`::` is used to access _associated functions_, ie a function implemented on a
type.

## Statements and Expressions

Statements are instructions that perform some action and do not return a value.
Expressions evaluate to a resulting value.

Expressions do not include ending semicolons. If a semicolon is added, it is
turned into a statement.

## Enums

An enumeration is a type that can have a fixed set of values. Those values are
called _variants_.

### `Option` enum

`Option<T>` has variants `Some(T)` or `None`.

- Unwrap in a `match` statement.
- `.map()`
- `.and()`
- `.and_then()`
- `.or()`
- `.or_else()`
- `.ok_or()`

### `Result` enum

Rust does not have any exceptions, they are instead encoded in return types.
`Result` is the type used for returning and propagating errors.

`Result<T, E>` enum has variants `Ok(T)` and `Err(E)`.

- `.expect`: assert success with `expect`, or panic
- `?`: shortcut for `match` with return in error arm
- `.unwrap`: shortcut for `match` with `panic!` in error arm

**Best practice**: Use an enum for error type.

### `Ordering` enum

`use std::cmp::Ordering`

- `Ordering::Less`
- `Ordering::Greater`
- `Ordering::Equal`

## Module System

**crate**: is the smallest amount of code that the Rust compiler considers at a time.
Either _binary_ (executable) or _library_ (no main function).

The **crate root** is a source file that the Rust compiler starts from and makes up the root module of your crate.

A **package** is a bundle of one or more crates that provides a set of functionality.
A package contains a _Cargo.toml_ file that describes how to build those crates.

**Note**: A package can contain as many binary crates as you like, but at most only one library crate.
Additional binary crates are placed in the *src/bin* directory: each file will be a separate binary crate.

**Note**: A package must contain at least one crate, whether thatâ€™s a library or binary crate.

`use` keyword brings a path into scope.

`pub` keyword make items public

## Style

- place source code under `src/`
- Use 4 spaces
- snake_case for functions and variables
- Open curly brackets on same row
- use `cargo`
